---
title: "NFS data generation"
output: github_document
---

This is a typical example how we proceed to detect forks, initiations and terminations from the reads base_called with megalodon and our model (script=*basecalling_sample.sh*) then parsed with the *Parsing_function4Megalodon.r*  (script=*basecalling_sample.r*).  

### Background threshold determination
The first step of the analysis requires to check the distribution of the signal in order to set the b2a threshold, used to identify the background of the signal.  
This script outputs a PDF file corresponding to the distribution of the BrdU signal in 1kb bins for the reads filtered the presence of 3 and more linear segments. 

```{r eval = FALSE}
suppressMessages(library(tidyverse))
`%+%`<- paste0
source("./helper_function.r")
source("./NFS_function.r")
expmeg <- "JP3A_Megalodon_00_smdata.rds"
pathdata <- "~/work/Ori/newRaw_nt/"
ex.name <- "Exp_Test"
EXP <- readRDS(pathdata %+% expmeg)  %>% filter(chrom!="chrM")
plot_signal(EXP,EXPname=ex.name,EXP_b2a.thr0=0.02,alldata=F,nreads=5000,saved=T,plotit=T)
```
 
It is also possible to output the distribution for all the reads (of at least 5kb) but usually this distribution is less informative due to the overwhelming presence of reads with very low signal. 
From the second plot of the PDF file (a zoom of the first plot of th e PDF), it is possible to draw a line between the 0 level signal (background) and the informative signal which usually come in two wide distribution. One of medium level mode corresponding to the DNA replicated during the chase and one with higher level mode corresponding to the DNA replicated during the pulse.  
The position of this line was the threshold we fixed for our further analysis. This threshold was quite similar between all the experiments we analyzed, thus a fixed threshold of 0.02 was chosen to simplify the pipeline.  
We also limit to 5000 the number of reads used for this evaluation to speed up the computation but all the reads can be used by setting nreads=NA.  

### NFS analysis
Once the user has checked that the distribution of the signal and the position of the background threshold (ex.b2a in the following script) are satisfactory, the proper forks detection can be performed.  
This procedure create an output file saved in the .rds format. The data are organized as a list or 4 elements:  
1- a list of tibble containing:  
1.1- the reads filtered for their size and the presence of 3 and more linear segments.  
1.2- the reads with detected forks.  
2- a tibble of all the detected forks.  
3- a tibble containing the initiations (Init) and the terminations (Ter) detected.  
4- a table summary of different metrics of the experiment.   
```{r eval = FALSE}
library(GenomicRanges)
suppressMessages(library(kmlShape))
suppressMessages(library(tidyverse))
`%+%`<- paste0
source("./NFS_function.r")

seqinf <- Seqinfo(seqnames=c("chrI","chrII","chrIII","chrIV","chrV","chrVI","chrVII","chrVIII","chrIX","chrX","chrXI","chrXII","chrXIII","chrXIV","chrXV","chrXVI","chrM","rDNA-10R"),seqlengths=c(230218,813184,316620,1531933,576874,270161,1090940,562643,439888,745751,666816,1078177,924431,784333,1091291,948066,85779,113097), isCircular=c(rep(F,16),T,F),genome="S288CrDNA")

pathdata <- "~/work/Ori/newRaw_nt/"
expmeg <- "JP3A_Megalodon_00_smdata.rds"
ex.name <- "Exp_Test"
ex.pulse <- 2
ex.b2a <- 0.02
EXP <- readRDS(pathdata %+% expmeg)  %>% filter(chrom!="chrM")
EXP_NFS <- NFSmaster(EXP,pulse0=ex.pulse,NFS.save=T,EXPname=ex.name %+% "_nt",b2a=ex.b2a)
```

As parsed data file were big, fork detection is performed on the split data and then these results are merged using the NFS_merging function from the *NFS_function.r* file.  
The merged data file keep the same organization with a slightly simplified summary table. Those merged file are then used to produce the figures and data discussed in the manuscript [Theulot et al., 2022](https://doi.org/XX.XXXXX/JOURNAL/REF).  
```{r eval = FALSE}
source("./NFS_function.r")
NFS_merging ("./","./","Exp_Test",suff="_merged",file_list0="Exp_Test_nt_NFS_data.rds")
```

### Outpout data format explanation

##### NFSmaster output
1 NFS_data  
1.1: NFS_data$allRDP3  

This tibble contains all the reads analyzed containing at least 3 linear segments after "Piecewise Linear Simplification".  
- read_id= read identifier  
- chrom= mapped chromosome  
- start= start of the mapped read (1-based)  
- end= end of the mapped read  
- strand= strand of the mapped read  
- gap_pos= position of gaps introduced during the alignment  
- signalr= BrdU signal along the mapped read (positions=chromosomal coordinate, Bprob= raw BrdU probability from megodon witu our model), signal=smoothed BrdU signal using first a 100nt rolling mean then a 2500nt rolling weighted mean with a gaussian weight function)  
- length= length of the read  
- smBmedy= median of the smoothed BrdU signal  
- Bmedy= median of the raw BrdU signal  
- RDP= Piecewise Linear Simplification of the smoothed signal using the Ramer Douglas Peucker algorithm (x,y = positions of extremities of the linear segments)  
- RDP.length= number segment+1  
- sl2= slope results after letter affectation  
- forks= position of the forks indicating the positions of the identifed start of the pulse (X0,Y0), end of the pulse (X1,Y1) and end of the last un amibiguous chase segment (X2, which might not coincide with the end of the chase), average speed during the pulse (speed), average signal slope during the pulse (sl_pulse) and the begining of the chase (sl_chase) and BrdU signal amplitude (d.Y, >0 for for rightward forks,<0 for for leftward forks )  
- n.forks= number of forks detected in the read  

1.2: NFS_data$with_forks  

same structure as NFS_data$allRDP3 after filtering out of the forks overlapping an alignment gap.    


#### NFS_merging output

